commit 08cc7a5c8feba34963e1e25c6282ebecc4c9c84e
Author: UnbelievableFlavour <bart.zaalberg@shift2.nl>
Date:   Wed Feb 25 08:41:57 2026 +0100

    Use container language for GOG downloads (#627)
    
    * Use container language for GOG downloads
    
    Falls back to english
    
    * Updated GOG code to download language files after update in container, and to only download files that don't exist.
    
    * Prevent corruption in size-only incremental check
    
    * Gen 1 expected-bytes includes support files even when they are not downloaded.
    
    * Added guardrails for Language-change
    
    ---------
    
    Co-authored-by: Utkarsh Dalal <utkarsh.dalal@toptal.com>
---
 .../app/gamenative/service/gog/GOGConstants.kt     | 46 +++++++++++++-
 .../gamenative/service/gog/GOGDownloadManager.kt   | 74 ++++++++++++++++------
 .../java/app/gamenative/service/gog/GOGService.kt  |  4 +-
 .../gamenative/service/gog/api/GOGDataModels.kt    | 14 ++--
 .../service/gog/api/GOGManifestParser.kt           | 56 ++++++++++------
 .../ui/screen/library/appscreen/GOGAppScreen.kt    | 21 +++++-
 .../service/gog/api/GOGManifestParserTest.kt       | 34 ++++++++--
 7 files changed, 188 insertions(+), 61 deletions(-)

diff --git a/app/src/main/java/app/gamenative/service/gog/GOGConstants.kt b/app/src/main/java/app/gamenative/service/gog/GOGConstants.kt
index 68628b2..4d3230f 100644
--- a/app/src/main/java/app/gamenative/service/gog/GOGConstants.kt
+++ b/app/src/main/java/app/gamenative/service/gog/GOGConstants.kt
@@ -42,7 +42,51 @@ object GOGConstants {
             "&layout=galaxy"
 
     /** GOG download language (short code as used in manifest depots, e.g. "en"). */
-    const val GOG_DOWNLOAD_LANGUAGE = "en"
+    const val GOG_FALLBACK_DOWNLOAD_LANGUAGE = "english"
+
+    /**
+     * GOG language codes per container language: primary code first, then fallbacks (as in GOG's Language list).
+     * Keys match [PrefManager.containerLanguage]. Unknown languages fall back to English.
+     */
+    internal val CONTAINER_LANGUAGE_TO_GOG_CODES: Map<String, List<String>> = mapOf(
+        "arabic" to listOf("ar"),
+        "bulgarian" to listOf("bg-BG", "bg", "bl"),
+        "schinese" to listOf("zh-Hans", "zh_Hans", "zh", "cn"),
+        "tchinese" to listOf("zh-Hant", "zh_Hant"),
+        "czech" to listOf("cs-CZ", "cz"),
+        "danish" to listOf("da-DK", "da"),
+        "dutch" to listOf("nl-NL", "nl"),
+        "english" to listOf("en-US", "en"),
+        "finnish" to listOf("fi-FI", "fi"),
+        "french" to listOf("fr-FR", "fr"),
+        "german" to listOf("de-DE", "de"),
+        "greek" to listOf("el-GR", "gk", "el-GK"),
+        "hungarian" to listOf("hu-HU", "hu"),
+        "italian" to listOf("it-IT", "it"),
+        "japanese" to listOf("ja-JP", "jp"),
+        "koreana" to listOf("ko-KR", "ko"),
+        "norwegian" to listOf("nb-NO", "no"),
+        "polish" to listOf("pl-PL", "pl"),
+        "portuguese" to listOf("pt-PT", "pt"),
+        "brazilian" to listOf("pt-BR", "br"),
+        "romanian" to listOf("ro-RO", "ro"),
+        "russian" to listOf("ru-RU", "ru"),
+        "spanish" to listOf("es-ES", "es"),
+        "latam" to listOf("es-MX", "es_mx"),
+        "swedish" to listOf("sv-SE", "sv"),
+        "thai" to listOf("th-TH", "th"),
+        "turkish" to listOf("tr-TR", "tr"),
+        "ukrainian" to listOf("uk-UA", "uk"),
+        "vietnamese" to listOf("vi-VN", "vi"),
+    )
+
+    /**
+     * Maps container language name (e.g. "english", "german") to an ordered list of GOG manifest language codes
+     * (primary first, then fallbacks). Uses the same names as [PrefManager.containerLanguage].
+     * Returns English codes (CONTAINER_LANGUAGE_TO_GOG_CODES.getValue(GOG_FALLBACK_DOWNLOAD_LANGUAGE)) for unknown languages.
+     */
+    fun containerLanguageToGogCodes(containerLanguage: String): List<String> =
+        CONTAINER_LANGUAGE_TO_GOG_CODES[containerLanguage.lowercase()] ?: CONTAINER_LANGUAGE_TO_GOG_CODES.getValue(GOG_FALLBACK_DOWNLOAD_LANGUAGE)
 
     /**
      * Builds a full Galaxy OAuth login URL with a fresh state parameter for CSRF protection.
diff --git a/app/src/main/java/app/gamenative/service/gog/GOGDownloadManager.kt b/app/src/main/java/app/gamenative/service/gog/GOGDownloadManager.kt
index 582180f..c9d769c 100644
--- a/app/src/main/java/app/gamenative/service/gog/GOGDownloadManager.kt
+++ b/app/src/main/java/app/gamenative/service/gog/GOGDownloadManager.kt
@@ -86,7 +86,7 @@ class GOGDownloadManager @Inject constructor(
      * @param gameId GOG game ID (numeric)
      * @param installPath Directory where game will be installed
      * @param downloadInfo Progress tracker
-     * @param language Target language (see [GOGConstants.GOG_DOWNLOAD_LANGUAGE])
+     * @param language Container language name (e.g. "english", "german"). Used to resolve GOG manifest language codes when filtering depots. See [GOGConstants.containerLanguageToGogCodes].
      * @param withDlcs Whether to include DLC content
      * @param supportDir Optional directory for support files (redistributables)
      * @return Result indicating success or failure
@@ -95,7 +95,7 @@ class GOGDownloadManager @Inject constructor(
         gameId: String,
         installPath: File,
         downloadInfo: DownloadInfo,
-        language: String = GOGConstants.GOG_DOWNLOAD_LANGUAGE,
+        language: String = GOGConstants.GOG_FALLBACK_DOWNLOAD_LANGUAGE,
         withDlcs: Boolean = false,
         supportDir: File? = null,
     ): Result<Unit> = withContext(Dispatchers.IO) {
@@ -194,26 +194,28 @@ class GOGDownloadManager @Inject constructor(
 
             downloadInfo.updateStatusMessage("Filtering depots...")
 
-            // Step 3: Filter depots by language and bitness (32-bit or 64-bit)
-            val languageDepots = parser.filterDepotsByLanguage(gameManifest, language)
+            // Step 3: Filter depots by container language (parser resolves to GOG codes and tries English fallback)
+            val (languageDepots, effectiveLang) = parser.filterDepotsByLanguage(gameManifest, language)
             if (languageDepots.isEmpty()) {
-                return@withContext Result.failure(Exception("No depots found for language: $language"))
+                return@withContext Result.failure(
+                    Exception("No depots found for any requested or fallback (English) languages"),
+                )
             }
 
-            // TODO: Verify if we need this anymore.
+            // Step 4: Filter depots by OS bitness
             val bitnessDepots = parser.filterDepotsByBitness(languageDepots, bitness = "64")
             if (bitnessDepots.isEmpty()) {
-                return@withContext Result.failure(Exception("No 64-bit depots found for language: $language"))
+                return@withContext Result.failure(Exception("No 64-bit depots found for language: $effectiveLang"))
             }
 
             // Filter by ownership to exclude unowned DLC depots
             val ownedGameIds = gogManager.getAllGameIds()
             val depots = parser.filterDepotsByOwnership(bitnessDepots, ownedGameIds)
             if (depots.isEmpty()) {
-                return@withContext Result.failure(Exception("No owned depots found for language: $language"))
+                return@withContext Result.failure(Exception("No owned depots found for language: $effectiveLang"))
             }
 
-            Timber.tag("GOG").d("Found ${depots.size} owned depot(s) for $language (64-bit)")
+            Timber.tag("GOG").d("Found ${depots.size} owned depot(s) for $effectiveLang (64-bit)")
             depots.forEachIndexed { index, depot ->
                 Timber.tag("GOG").d("  Depot $index: productId=${depot.productId}, manifest=${depot.manifest}, size=${depot.size}, compressedSize=${depot.compressedSize}")
             }
@@ -247,7 +249,17 @@ class GOGDownloadManager @Inject constructor(
             // Step 5: Separate base game, DLC, and support files
             val (baseFiles, dlcFiles) = parser.separateBaseDLC(allFiles, gameManifest.baseProductId)
             val filesToDownload = if (withDlcs) baseFiles + dlcFiles else baseFiles
-            val (gameFiles, supportFiles) = parser.separateSupportFiles(filesToDownload)
+            var (gameFiles, supportFiles) = parser.separateSupportFiles(filesToDownload)
+
+            // Filter out files that already exist with correct size (incremental download)
+            val gameInstallDir = installPath
+            val beforeCount = gameFiles.size
+            gameFiles = gameFiles.filter { file ->
+                val outputFile = File(gameInstallDir, file.path)
+                val expectedSize = file.chunks.sumOf { it.size }
+                !fileExistsWithCorrectSize(outputFile, expectedSize, file.md5)
+            }
+            Timber.tag("GOG").d("Skipping ${beforeCount - gameFiles.size} existing file(s), downloading ${gameFiles.size}")
 
             // Calculate sizes separately for transparency
             val (baseGameFiles, _) = parser.separateSupportFiles(baseFiles)
@@ -296,8 +308,10 @@ class GOGDownloadManager @Inject constructor(
 
             Timber.tag("GOG").d("Mapping chunks to products. gameId parameter: $gameId, realGameId: $realGameId, manifest baseProductId: ${gameManifest.baseProductId}")
 
+            val filesToDownloadPaths = gameFiles.map { it.path }.toSet()
             // Map each chunk to its product ID using depot info
             allFilesWithDepots.forEach { (file, depotProductId) ->
+                if (file.path !in filesToDownloadPaths) return@forEach
                 // Use depot's productId as fallback when file has null/placeholder productId
 
                 // TODO: Remove this logic and always use the depotProductId.
@@ -384,7 +398,6 @@ class GOGDownloadManager @Inject constructor(
             downloadInfo.updateStatusMessage("Assembling files...")
 
             // Use installPath directly since it already includes the game-specific folder
-            val gameInstallDir = installPath
             gameInstallDir.mkdirs()
 
             val assembleResult = assembleFiles(gameFiles, chunkCacheDir, gameInstallDir, downloadInfo)
@@ -407,8 +420,7 @@ class GOGDownloadManager @Inject constructor(
             // Step 11: Cleanup
             chunkCacheDir.deleteRecursively()
 
-            val effectiveLanguage = parser.getEffectiveLanguageFromDepots(depots, language)
-            saveManifestToGameDir(installPath, gameManifest, selectedBuild.buildId, selectedBuild.versionName, effectiveLanguage)
+            saveManifestToGameDir(installPath, gameManifest, selectedBuild.buildId, selectedBuild.versionName, effectiveLang)
 
             finalizeInstallSuccess(gameId, installPath, downloadInfo)
             Timber.tag("GOG").i("Download completed successfully for game $gameId")
@@ -559,16 +571,27 @@ class GOGDownloadManager @Inject constructor(
                 v1Files.forEach { allV1Files.add(FileWithProduct(it, depot.productId)) }
             }
 
-            val gameFiles = allV1Files.filter { !it.file.isSupport }
-            val supportFiles = allV1Files.filter { it.file.isSupport }
-            val totalSize = gameFiles.sumOf { it.file.size } + supportFiles.sumOf { it.file.size }
+            var gameFiles = allV1Files.filter { !it.file.isSupport }
+            var supportFiles = allV1Files.filter { it.file.isSupport }
+            gameFiles = gameFiles.filter { f ->
+                val outFile = File(installPath, f.file.path)
+                !fileExistsWithCorrectSize(outFile, f.file.size, f.file.hash.takeIf { it.isNotEmpty() })
+            }
+            if (supportDir != null) {
+                supportFiles = supportFiles.filter { f ->
+                    val outFile = File(supportDir, f.file.path)
+                    !fileExistsWithCorrectSize(outFile, f.file.size, f.file.hash.takeIf { it.isNotEmpty() })
+                }
+            }
+            val totalSize = gameFiles.sumOf { it.file.size } +
+                if (supportDir != null) supportFiles.sumOf { it.file.size } else 0L
             downloadInfo.setTotalExpectedBytes(totalSize)
             downloadInfo.updateStatusMessage("Downloading files...")
             downloadInfo.setProgress(0f)
             downloadInfo.setActive(true)
             downloadInfo.emitProgressChange()
 
-            val totalFiles = gameFiles.size + supportFiles.size
+            val totalFiles = gameFiles.size + if (supportDir != null) supportFiles.size else 0
             var doneFiles = 0
 
             // Gen 1: one main.bin URL per product; each file is fetched with Range: bytes=offset-(offset+size-1)
@@ -667,8 +690,8 @@ class GOGDownloadManager @Inject constructor(
                 }
             }
 
-            val effectiveLanguage = parser.getEffectiveLanguageFromDepots(filesToDownload, language)
-            saveManifestToGameDir(installPath, gameManifest, selectedBuild.buildId, selectedBuild.versionName, effectiveLanguage)
+            val (_, effectiveLang) = parser.filterDepotsByLanguage(gameManifest, language)
+            saveManifestToGameDir(installPath, gameManifest, selectedBuild.buildId, selectedBuild.versionName, effectiveLang)
 
             finalizeInstallSuccess(gameId, installPath, downloadInfo)
             Timber.tag("GOG").i("Gen 1 download completed for game $gameId")
@@ -1387,6 +1410,19 @@ class GOGDownloadManager @Inject constructor(
         return digest.digest().joinToString("") { "%02x".format(it) }
     }
 
+    /**
+     * Check if file exists and has the expected size. When [expectedMd5] is non-null/non-blank,
+     * also verifies content MD5 to reject corrupted files; short-circuits on size mismatch before hashing.
+     */
+    private fun fileExistsWithCorrectSize(
+        outputFile: File,
+        expectedSize: Long,
+        expectedMd5: String? = null,
+    ): Boolean {
+        if (!outputFile.exists()) return false
+        if (outputFile.length() != expectedSize) return false
+        return expectedMd5.isNullOrBlank() || calculateMd5File(outputFile).equals(expectedMd5, ignoreCase = true)
+    }
     /**
      * Calculate MD5 hash of file
      */
diff --git a/app/src/main/java/app/gamenative/service/gog/GOGService.kt b/app/src/main/java/app/gamenative/service/gog/GOGService.kt
index 9cd2694..20d5281 100644
--- a/app/src/main/java/app/gamenative/service/gog/GOGService.kt
+++ b/app/src/main/java/app/gamenative/service/gog/GOGService.kt
@@ -295,7 +295,7 @@ class GOGService : Service() {
             getInstance()?.gogManager?.runScriptInterpreterIfNeeded(appId, guestProgramLauncherComponent)
         }
 
-        fun downloadGame(context: Context, gameId: String, installPath: String): Result<DownloadInfo?> {
+        fun downloadGame(context: Context, gameId: String, installPath: String, containerLanguage: String): Result<DownloadInfo?> {
             val instance = getInstance() ?: return Result.failure(Exception("Service not available"))
 
             // Create DownloadInfo for progress tracking
@@ -313,7 +313,7 @@ class GOGService : Service() {
 
                     val result = instance.gogDownloadManager.downloadGame(
                         gameId, File(installPath),
-                        downloadInfo, GOGConstants.GOG_DOWNLOAD_LANGUAGE, true, commonRedistDir,
+                        downloadInfo, containerLanguage, true, commonRedistDir,
                     )
 
                     if (result.isFailure) {
diff --git a/app/src/main/java/app/gamenative/service/gog/api/GOGDataModels.kt b/app/src/main/java/app/gamenative/service/gog/api/GOGDataModels.kt
index 6cb0057..714e310 100644
--- a/app/src/main/java/app/gamenative/service/gog/api/GOGDataModels.kt
+++ b/app/src/main/java/app/gamenative/service/gog/api/GOGDataModels.kt
@@ -277,17 +277,11 @@ data class Depot(
     }
 
     /**
-     * Check if this depot matches the target language (e.g. "en" or "en-US").
-     * Uses exact match plus deprecated/short codes so "en" matches depots with "en" or "en-US".
+     * True if this depot lists the target language (case-insensitive exact match).
+     * Fallback and deprecated code handling (e.g. en vs en-US) is done by the caller.
      */
-    fun matchesLanguage(targetLanguage: String): Boolean {
-        if (languages.contains("*")) return true
-        return languages.any { depotLang ->
-            depotLang.equals(targetLanguage, ignoreCase = true) ||
-                GOG_LANGUAGE_DEPRECATED[depotLang]?.any { it.equals(targetLanguage, ignoreCase = true) } == true ||
-                GOG_LANGUAGE_DEPRECATED[targetLanguage]?.any { it.equals(depotLang, ignoreCase = true) } == true
-        }
-    }
+    fun matchesLanguage(targetLanguage: String): Boolean =
+        languages.any { it.equals(targetLanguage, ignoreCase = true) }
 }
 
 /**
diff --git a/app/src/main/java/app/gamenative/service/gog/api/GOGManifestParser.kt b/app/src/main/java/app/gamenative/service/gog/api/GOGManifestParser.kt
index 0040f01..e7b5ee6 100644
--- a/app/src/main/java/app/gamenative/service/gog/api/GOGManifestParser.kt
+++ b/app/src/main/java/app/gamenative/service/gog/api/GOGManifestParser.kt
@@ -1,5 +1,6 @@
 package app.gamenative.service.gog.api
 
+import app.gamenative.service.gog.GOGConstants
 import timber.log.Timber
 import java.io.ByteArrayInputStream
 import java.io.ByteArrayOutputStream
@@ -54,30 +55,45 @@ class GOGManifestParser @Inject constructor() {
     }
 
     /**
-     * Filter depots based on language
+     * Filter depots based on container language. Resolves container language to GOG manifest codes
+     * via [GOGConstants.containerLanguageToGogCodes], tries each in order, and for each tries English
+     * fallback if needed. Returns the first non-empty result.
      *
      * @param manifest Main manifest metadata
-     * @param language Target language (e.g., "en-US") or is *
-     * @return Filtered list of depots matching language
+     * @param containerLanguage Container language name (e.g. "english", "german"). See [GOGConstants.containerLanguageToGogCodes].
+     * @return Pair of (filtered list of depots, effective GOG language code that matched)
      */
-    fun filterDepotsByLanguage(manifest: GOGManifestMeta, language: String): List<Depot> {
-        val filtered = manifest.depots.filter { depot ->
-            depot.matchesLanguage(language) || (depot.languages?.contains("*") == true)
+    fun filterDepotsByLanguage(manifest: GOGManifestMeta, containerLanguage: String): Pair<List<Depot>, String> {
+        val allDepotLangCodes = manifest.depots.flatMap { it.languages }.distinct().sorted()
+        Timber.tag(TAG).d("Language depots codes in manifest: $allDepotLangCodes")
+
+        val starDepots = manifest.depots.filter { it.matchesLanguage("*") }
+        fun filter(lang: String): List<Depot> = manifest.depots.filter { it.matchesLanguage(lang) }
+        val requestedCodes = GOGConstants.containerLanguageToGogCodes(containerLanguage)
+        val englishCodes = GOGConstants.CONTAINER_LANGUAGE_TO_GOG_CODES.getValue(GOGConstants.GOG_FALLBACK_DOWNLOAD_LANGUAGE)
+
+        // Try all requested language codes first (e.g. de-DE, then de)
+        for (lang in requestedCodes) {
+            val matched = filter(lang)
+            if (matched.isNotEmpty()) {
+                val result = (matched + starDepots).distinct()
+                Timber.tag(TAG).d("Filtered ${result.size}/${manifest.depots.size} depots for language: $lang")
+                return result to lang
+            }
         }
-
-        Timber.tag(TAG).d("Filtered ${filtered.size}/${manifest.depots.size} depots for language: $language")
-        return filtered
-    }
-
-    /**
-     * Derives the effective language from the depots actually used for download.
-     * Prefers the requested language if any depot matches it; otherwise uses the first concrete
-     * language from the depots (e.g. after fallback to "*" or other languages).
-     */
-    fun getEffectiveLanguageFromDepots(depots: List<Depot>, requestedLanguage: String): String {
-        if (depots.any { it.matchesLanguage(requestedLanguage) }) return requestedLanguage
-        val fromDepots = depots.flatMap { it.languages }.firstOrNull { it != "*" }
-        return fromDepots ?: requestedLanguage
+        // Only then try English fallbacks (en-US, then en)
+        for (fallbackLang in englishCodes) {
+            val matched = filter(fallbackLang)
+            if (matched.isNotEmpty()) {
+                val result = (matched + starDepots).distinct()
+                Timber.tag(TAG).d("No depots for requested language codes, fell back to $fallbackLang: ${result.size}/${manifest.depots.size} depots")
+                return result to fallbackLang
+            }
+        }
+        // No language-specific match: return all depots with first requested language as effective
+        val effectiveLang = requestedCodes.firstOrNull() ?: "en"
+        Timber.tag(TAG).d("No language match for $containerLanguage, using all ${manifest.depots.size} depots with effective: $effectiveLang")
+        return manifest.depots to effectiveLang
     }
 
     /**
diff --git a/app/src/main/java/app/gamenative/ui/screen/library/appscreen/GOGAppScreen.kt b/app/src/main/java/app/gamenative/ui/screen/library/appscreen/GOGAppScreen.kt
index 02bbc06..1d18fb5 100644
--- a/app/src/main/java/app/gamenative/ui/screen/library/appscreen/GOGAppScreen.kt
+++ b/app/src/main/java/app/gamenative/ui/screen/library/appscreen/GOGAppScreen.kt
@@ -22,6 +22,7 @@ import app.gamenative.service.gog.GOGService
 import app.gamenative.ui.data.AppMenuOption
 import app.gamenative.ui.data.GameDisplayInfo
 import app.gamenative.ui.enums.AppOptionMenuType
+import app.gamenative.utils.ContainerUtils.getContainer
 import com.winlator.container.ContainerData
 import java.util.Locale
 import kotlinx.coroutines.CoroutineScope
@@ -265,6 +266,8 @@ class GOGAppScreen : BaseAppScreen() {
             try {
                 // Get install path
                 val installPath = GOGConstants.getGameInstallPath(libraryItem.name)
+                val containerData = loadContainerData(context, libraryItem)
+
                 Timber.d("Downloading GOG game to: $installPath")
 
                 // Show starting download toast
@@ -277,7 +280,7 @@ class GOGAppScreen : BaseAppScreen() {
                 }
 
                 // Start download - GOGService will handle monitoring, database updates, verification, and events
-                val result = GOGService.downloadGame(context, gameId, installPath)
+                val result = GOGService.downloadGame(context, gameId, installPath, containerData.language)
 
                 if (result.isSuccess) {
                     Timber.i("GOG download started successfully for: $gameId")
@@ -422,9 +425,23 @@ class GOGAppScreen : BaseAppScreen() {
 
     override fun saveContainerConfig(context: Context, libraryItem: LibraryItem, config: ContainerData) {
         Timber.tag(TAG).i("saveContainerConfig: appId=${libraryItem.appId}")
-        // Save GOG-specific container configuration using ContainerUtils
+        val container = getContainer(context, libraryItem.appId)
+        val previousLanguage = container.language
         app.gamenative.utils.ContainerUtils.applyToContainer(context, libraryItem.appId, config)
         Timber.tag(TAG).d("saveContainerConfig: saved container config for ${libraryItem.appId}")
+
+        if (previousLanguage != config.language) {
+            CoroutineScope(Dispatchers.IO).launch {
+                val gameId = libraryItem.gameId.toString()
+                if (!GOGService.isGameInstalled(gameId)) return@launch
+                if (GOGService.getDownloadInfo(gameId)?.isActive() == true) return@launch
+
+                val installPath = GOGService.getInstallPath(gameId)
+                    ?: GOGConstants.getGameInstallPath(libraryItem.name)
+
+                GOGService.downloadGame(context, gameId, installPath, config.language)
+            }
+        }
     }
 
     override fun supportsContainerConfig(): Boolean {
diff --git a/app/src/test/java/app/gamenative/service/gog/api/GOGManifestParserTest.kt b/app/src/test/java/app/gamenative/service/gog/api/GOGManifestParserTest.kt
index e62bfdd..729cc07 100644
--- a/app/src/test/java/app/gamenative/service/gog/api/GOGManifestParserTest.kt
+++ b/app/src/test/java/app/gamenative/service/gog/api/GOGManifestParserTest.kt
@@ -136,15 +136,16 @@ class GOGManifestParserTest {
             products = emptyList(),
         )
 
-        val result = parser.filterDepotsByLanguage(manifest, GOGConstants.GOG_DOWNLOAD_LANGUAGE)
+        val (depots, effectiveLang) = parser.filterDepotsByLanguage(manifest, "english")
 
-        assertEquals(1, result.size)
-        assertTrue(result[0].languages.contains("en"))
+        assertEquals(1, depots.size)
+        assertTrue(depots[0].languages.contains("en"))
+        assertTrue(effectiveLang in GOGConstants.CONTAINER_LANGUAGE_TO_GOG_CODES.getValue(GOGConstants.GOG_FALLBACK_DOWNLOAD_LANGUAGE))
     }
 
     @Test
     fun testFilterDepotsByLanguage_enUSMatchesEn() {
-        // Games using en-US in manifest should still match when we request "en" (GOG_DOWNLOAD_LANGUAGE)
+        // Container language "english" resolves to en-US, en; games using en-US in manifest should match
         val enUSDepot = createTestDepot(languages = listOf("en-US"))
         val frDepot = createTestDepot(languages = listOf("fr"))
         val manifest = GOGManifestMeta(
@@ -155,10 +156,29 @@ class GOGManifestParserTest {
             products = emptyList(),
         )
 
-        val result = parser.filterDepotsByLanguage(manifest, GOGConstants.GOG_DOWNLOAD_LANGUAGE)
+        val (depots, effectiveLang) = parser.filterDepotsByLanguage(manifest, "english")
 
-        assertEquals(1, result.size)
-        assertTrue(result[0].languages.contains("en-US"))
+        assertEquals(1, depots.size)
+        assertTrue(depots[0].languages.contains("en-US"))
+        assertTrue(effectiveLang in GOGConstants.CONTAINER_LANGUAGE_TO_GOG_CODES.getValue(GOGConstants.GOG_FALLBACK_DOWNLOAD_LANGUAGE))
+    }
+
+    @Test
+    fun testFilterDepotsByLanguage_fallbackToEnglishWhenRequestedLanguageHasNoDepots() {
+        val enUSDepot = createTestDepot(languages = listOf("en-US"))
+        val manifest = GOGManifestMeta(
+            baseProductId = "12345",
+            installDirectory = "game",
+            depots = listOf(enUSDepot),
+            dependencies = emptyList(),
+            products = emptyList(),
+        )
+
+        val (depots, effectiveLang) = parser.filterDepotsByLanguage(manifest, "greek")
+
+        assertEquals(1, depots.size)
+        assertTrue(depots[0].languages.contains("en-US"))
+        assertTrue(effectiveLang in GOGConstants.CONTAINER_LANGUAGE_TO_GOG_CODES.getValue(GOGConstants.GOG_FALLBACK_DOWNLOAD_LANGUAGE))
     }
 
     @Test
