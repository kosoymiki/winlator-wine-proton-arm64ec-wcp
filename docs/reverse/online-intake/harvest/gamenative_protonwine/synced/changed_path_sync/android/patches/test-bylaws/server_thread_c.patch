diff --git a/server/thread.c b/server/thread.c
index 25b91a9..42bd48d 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -305,6 +305,7 @@ static inline void init_thread_structure( struct thread *thread )
     thread->priority        = 0;
     thread->suspend         = 0;
     thread->dbg_hidden      = 0;
+    thread->bypass_proc_suspend = 0;
     thread->desktop_users   = 0;
     thread->token           = NULL;
     thread->desc            = NULL;
@@ -323,6 +324,11 @@ static inline void init_thread_structure( struct thread *thread )
         thread->inflight[i].server = thread->inflight[i].client = -1;
 }
 
+static int get_effective_proc_suspend( struct thread *thread )
+{
+    return thread->bypass_proc_suspend ? 0 : thread->process->suspend;
+}
+
 /* check if address looks valid for a client-side data structure (TEB etc.) */
 static inline int is_valid_address( client_ptr_t addr )
 {
@@ -833,7 +839,7 @@ int suspend_thread( struct thread *thread )
     int old_count = thread->suspend;
     if (thread->suspend < MAXIMUM_SUSPEND_COUNT)
     {
-        if (!(thread->process->suspend + thread->suspend++))
+        if (!(get_effective_proc_suspend( thread ) + thread->suspend++))
         {
             stop_thread( thread );
             if (thread == current) return old_count | 0x80000000;
@@ -850,7 +856,7 @@ int resume_thread( struct thread *thread )
     if (thread->suspend > 0)
     {
         if (!(--thread->suspend)) resume_delayed_debug_events( thread );
-        if (!(thread->suspend + thread->process->suspend)) wake_thread( thread );
+        if (!(thread->suspend + get_effective_proc_suspend( thread ))) wake_thread( thread );
     }
     return old_count;
 }
@@ -999,7 +1005,7 @@ static int check_wait( struct thread *thread )
         return STATUS_KERNEL_APC;
 
     /* Suspended threads may not acquire locks, but they can run system APCs */
-    if (thread->process->suspend + thread->suspend > 0) return -1;
+    if (get_effective_proc_suspend( thread ) + thread->suspend > 0) return -1;
 
     if (wait->select == SELECT_WAIT_ALL)
     {
@@ -1086,7 +1092,7 @@ int wake_thread_queue_entry( struct wait_queue_entry *entry )
     client_ptr_t cookie;
 
     if (thread->wait != wait) return 0;  /* not the current wait */
-    if (thread->process->suspend + thread->suspend > 0) return 0;  /* cannot acquire locks */
+    if (get_effective_proc_suspend( thread ) + thread->suspend > 0) return 0;  /* cannot acquire locks */
 
     assert( wait->select != SELECT_WAIT_ALL );
 
@@ -1109,7 +1115,7 @@ static void thread_timeout( void *ptr )
 
     wait->user = NULL;
     if (thread->wait != wait) return; /* not the top-level wait, ignore it */
-    if (thread->suspend + thread->process->suspend > 0) return;  /* suspended, ignore it */
+    if (thread->suspend + get_effective_proc_suspend( thread ) > 0) return;  /* suspended, ignore it */
 
     if (debug_level) fprintf( stderr, "%04x: *wakeup* signaled=TIMEOUT\n", thread->id );
     end_wait( thread, STATUS_TIMEOUT );
@@ -1549,6 +1555,7 @@ DECL_HANDLER(new_thread)
         thread->system_regs = current->system_regs;
         if (req->flags & THREAD_CREATE_FLAGS_CREATE_SUSPENDED) thread->suspend++;
         thread->dbg_hidden = !!(req->flags & THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER);
+        thread->bypass_proc_suspend = !!(req->flags & THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE);
         reply->tid = get_thread_id( thread );
         if ((reply->handle = alloc_handle_no_access_check( current->process, thread,
                                                            req->access, objattr->attributes )))
@@ -1665,7 +1672,7 @@ DECL_HANDLER(init_thread)
     apply_thread_priority( current, get_base_priority( current->process->priority, current->priority ));
     set_thread_affinity( current, current->affinity );
 
-    reply->suspend = (current->suspend || current->process->suspend || current->context != NULL);
+    reply->suspend = (current->suspend || get_effective_proc_suspend( current ) || current->context != NULL);
 }
 
 /* terminate a thread */
