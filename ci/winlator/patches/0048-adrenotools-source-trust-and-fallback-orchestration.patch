diff --git a/app/src/main/java/com/winlator/cmod/AdrenotoolsFragment.java b/app/src/main/java/com/winlator/cmod/AdrenotoolsFragment.java
index 20327c5..2c98f39 100644
--- a/app/src/main/java/com/winlator/cmod/AdrenotoolsFragment.java
+++ b/app/src/main/java/com/winlator/cmod/AdrenotoolsFragment.java
@@ -51,6 +51,7 @@ import java.net.URLDecoder;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.Date;
 import java.util.Locale;
 import java.util.regex.Matcher;
@@ -274,6 +275,9 @@ public class AdrenotoolsFragment extends Fragment {
             item.prerelease = false;
             item.sourcePageUrl = author.externalUrl;
             item.sourceLabel = "GameNative";
+            item.sourceTrustScore = 92;
+            item.sourceRoute = "native_feed";
+            item.sourceFallbackChain = "native_feed:gamenative.app/drivers";
             item.releaseNotesSnippet = getString(R.string.driver_browser_gamenative_release_note) +
                     (TextUtils.isEmpty(rawTitle) ? "" : ("\n• Raw label: " + rawTitle));
             items.add(item);
@@ -284,26 +288,67 @@ public class AdrenotoolsFragment extends Fragment {
     private ArrayList<RemoteDriverAssetItem> loadGithubDriverAssetItems(DriverSourceAuthor author, DriverFamily family,
                                                                         boolean forceRefresh) throws Exception {
         ArrayList<RemoteDriverAssetItem> items = new ArrayList<>();
+        ArrayList<String> fallbackChain = new ArrayList<>();
+        HashSet<String> visitedRepos = new HashSet<>();
         Exception lastError = null;
-        for (GithubRepoRef repo : author.getGithubRepos()) {
+
+        ArrayList<GithubRepoRef> explicitRepos = author.getGithubRepos();
+        int explicitIndex = 0;
+        for (GithubRepoRef repo : explicitRepos) {
+            if (repo == null || TextUtils.isEmpty(repo.owner) || TextUtils.isEmpty(repo.name)) continue;
+            String repoKey = (repo.owner + "/" + repo.name).toLowerCase(Locale.ROOT);
+            if (!visitedRepos.add(repoKey)) continue;
+
+            String route = explicitIndex == 0 ? "primary" : "fallback_" + explicitIndex;
+            fallbackChain.add(route + ":" + repo.owner + "/" + repo.name);
+            explicitIndex++;
+
             try {
                 ArrayList<RemoteDriverAssetItem> repoItems = loadGithubDriverAssetItemsFromRepo(author, family, repo, forceRefresh);
-                if (!repoItems.isEmpty()) return repoItems;
+                if (!repoItems.isEmpty()) {
+                    int trustScore = computeSourceTrustScore(author, repo, false, explicitIndex);
+                    for (RemoteDriverAssetItem item : repoItems) {
+                        item.sourceTrustScore = trustScore;
+                        item.sourceRoute = route;
+                        item.sourceFallbackChain = android.text.TextUtils.join(" -> ", fallbackChain);
+                    }
+                    items.addAll(repoItems);
+                }
             } catch (Exception e) {
                 lastError = e;
             }
         }
+
         if (items.isEmpty() && !TextUtils.isEmpty(author.repoOwner)) {
             try {
                 ArrayList<GithubRepoRef> discovered = discoverGithubReposForAuthor(author, family, forceRefresh);
+                int discoveredIndex = 0;
                 for (GithubRepoRef repo : discovered) {
+                    if (repo == null || TextUtils.isEmpty(repo.owner) || TextUtils.isEmpty(repo.name)) continue;
+                    String repoKey = (repo.owner + "/" + repo.name).toLowerCase(Locale.ROOT);
+                    if (!visitedRepos.add(repoKey)) continue;
+
+                    String route = "discovered_" + discoveredIndex;
+                    fallbackChain.add(route + ":" + repo.owner + "/" + repo.name);
+                    discoveredIndex++;
+
                     ArrayList<RemoteDriverAssetItem> repoItems = loadGithubDriverAssetItemsFromRepo(author, family, repo, forceRefresh);
-                    if (!repoItems.isEmpty()) return repoItems;
+                    if (!repoItems.isEmpty()) {
+                        int trustScore = computeSourceTrustScore(author, repo, true, discoveredIndex);
+                        for (RemoteDriverAssetItem item : repoItems) {
+                            item.sourceTrustScore = trustScore;
+                            item.sourceRoute = route;
+                            item.sourceFallbackChain = android.text.TextUtils.join(" -> ", fallbackChain);
+                        }
+                        items.addAll(repoItems);
+                    }
                 }
             } catch (Exception e) {
                 lastError = e;
             }
         }
+
+        items = mergeDriverItemsByIdentity(items, family);
         if (!items.isEmpty()) return items;
         if (lastError != null) throw lastError;
         return items;
@@ -382,6 +427,7 @@ public class AdrenotoolsFragment extends Fragment {
                 item.sourcePageUrl = !TextUtils.isEmpty(htmlUrl) ? htmlUrl
                         : String.format(Locale.ROOT, "https://github.com/%s/%s/releases", repo.owner, repo.name);
                 item.sourceLabel = repo.owner + "/" + repo.name;
+                item.sourceTrustScore = 50;
                 item.releaseNotesSnippet = buildReleaseNotesSnippet(body);
                 items.add(item);
             }
@@ -389,6 +435,75 @@ public class AdrenotoolsFragment extends Fragment {
         return items;
     }
 
+    private int computeSourceTrustScore(DriverSourceAuthor author, GithubRepoRef repo, boolean discovered, int position) {
+        int score = 60;
+        String repoName = repo.name != null ? repo.name.toLowerCase(Locale.ROOT) : "";
+        String owner = repo.owner != null ? repo.owner.toLowerCase(Locale.ROOT) : "";
+        String primaryOwner = author.repoOwner != null ? author.repoOwner.toLowerCase(Locale.ROOT) : "";
+        String primaryRepo = author.repoName != null ? author.repoName.toLowerCase(Locale.ROOT) : "";
+
+        if (!primaryOwner.isEmpty() && owner.equals(primaryOwner)) score += 12;
+        if (!primaryRepo.isEmpty() && repoName.equals(primaryRepo)) score += 24;
+        if (repoName.contains("turnip") || repoName.contains("freedreno")) score += 8;
+        if (repoName.contains("adreno") || repoName.contains("driver")) score += 5;
+        if (discovered) score -= 10;
+
+        int routePenalty = Math.max(0, position - 1) * 2;
+        score -= routePenalty;
+        if (score < 1) score = 1;
+        if (score > 100) score = 100;
+        return score;
+    }
+
+    private ArrayList<RemoteDriverAssetItem> mergeDriverItemsByIdentity(ArrayList<RemoteDriverAssetItem> items, DriverFamily family) {
+        if (items == null || items.isEmpty()) return new ArrayList<>();
+        LinkedHashMap<String, RemoteDriverAssetItem> merged = new LinkedHashMap<>();
+        for (RemoteDriverAssetItem candidate : items) {
+            if (candidate == null) continue;
+            String key = buildDriverIdentityKey(candidate, family);
+            if (TextUtils.isEmpty(key)) key = safeString(candidate.downloadUrl).toLowerCase(Locale.ROOT);
+            RemoteDriverAssetItem existing = merged.get(key);
+            if (existing == null || compareDriverPriority(candidate, existing, family) > 0) {
+                merged.put(key, candidate);
+            }
+        }
+        return new ArrayList<>(merged.values());
+    }
+
+    private String buildDriverIdentityKey(RemoteDriverAssetItem item, DriverFamily family) {
+        if (item == null) return "";
+        long semantic = computeSemanticSortKey(item, family);
+        if (semantic != Long.MIN_VALUE) {
+            return safeString(item.familyId).toLowerCase(Locale.ROOT)
+                    + "|" + semantic
+                    + "|" + (item.prerelease ? "beta" : "stable");
+        }
+
+        String asset = safeString(item.assetName).toLowerCase(Locale.ROOT)
+                .replace(".zip", "")
+                .replace('_', '-');
+        if (!asset.isEmpty()) return safeString(item.familyId).toLowerCase(Locale.ROOT) + "|" + asset;
+        return safeString(item.downloadUrl).toLowerCase(Locale.ROOT);
+    }
+
+    private int compareDriverPriority(RemoteDriverAssetItem a, RemoteDriverAssetItem b, DriverFamily family) {
+        if (a.sourceTrustScore != b.sourceTrustScore) {
+            return Integer.compare(a.sourceTrustScore, b.sourceTrustScore);
+        }
+
+        long aSemantic = computeSemanticSortKey(a, family);
+        long bSemantic = computeSemanticSortKey(b, family);
+        if (aSemantic != Long.MIN_VALUE || bSemantic != Long.MIN_VALUE) {
+            if (aSemantic != bSemantic) return Long.compare(aSemantic, bSemantic);
+        }
+
+        long aDate = parseIsoDateMillis(a.publishedAt);
+        long bDate = parseIsoDateMillis(b.publishedAt);
+        if (aDate != bDate) return Long.compare(aDate, bDate);
+        if (a.prerelease != b.prerelease) return a.prerelease ? -1 : 1;
+        return safeString(a.assetName).compareToIgnoreCase(safeString(b.assetName));
+    }
+
     private boolean isAdrenoDriverAssetCandidate(String assetName, String releaseName, String tagName) {
         String combined = (assetName + " " + releaseName + " " + tagName).toLowerCase(Locale.ROOT);
         if (combined.contains("dxvk") || combined.contains("vkd3d") || combined.contains("d8vk")
@@ -592,6 +707,9 @@ public class AdrenotoolsFragment extends Fragment {
             item.semanticSortKey = computeSemanticSortKey(item, family);
         }
         Collections.sort(items, (a, b) -> {
+            if (a.sourceTrustScore != b.sourceTrustScore) {
+                return Integer.compare(b.sourceTrustScore, a.sourceTrustScore);
+            }
             if (a.semanticSortKey != Long.MIN_VALUE && b.semanticSortKey != Long.MIN_VALUE && a.semanticSortKey != b.semanticSortKey) {
                 return Long.compare(b.semanticSortKey, a.semanticSortKey);
             }
@@ -606,9 +724,16 @@ public class AdrenotoolsFragment extends Fragment {
             return safeString(a.assetName).compareToIgnoreCase(safeString(b.assetName));
         });
 
+        int recommendedIndex = 0;
+        for (int i = 0; i < items.size(); i++) {
+            if (!items.get(i).prerelease) {
+                recommendedIndex = i;
+                break;
+            }
+        }
         for (int i = 0; i < items.size(); i++) {
             RemoteDriverAssetItem item = items.get(i);
-            item.recommended = i == 0;
+            item.recommended = i == recommendedIndex;
             decorateDriverItem(item, family);
         }
     }
@@ -667,13 +792,17 @@ public class AdrenotoolsFragment extends Fragment {
         item.displayTitle = releaseLabel;
         item.displaySubtitle = item.authorName + " • " + safeString(item.familyLabel)
                 + (!TextUtils.isEmpty(date) ? " • " + date : "")
-                + (item.prerelease ? " • " + getString(R.string.channel_beta) : "");
+                + (item.prerelease ? " • " + getString(R.string.channel_beta) : "")
+                + (item.sourceTrustScore > 0 ? " • trust " + item.sourceTrustScore : "");
         if ("gamenative".equals(item.sourceKind) && !TextUtils.isEmpty(item.releaseName)
                 && !item.releaseName.equalsIgnoreCase(releaseLabel)) {
             item.displayMeta = safeString(item.assetName) + " • " + item.releaseName;
         } else {
             item.displayMeta = safeString(item.assetName);
         }
+        if (!TextUtils.isEmpty(item.sourceRoute)) {
+            item.displayMeta = item.displayMeta + " • " + item.sourceRoute;
+        }
         item.label = item.displayTitle + "\n" + item.displaySubtitle + "\n" + item.displayMeta;
     }
 
@@ -716,6 +845,9 @@ public class AdrenotoolsFragment extends Fragment {
         if (!TextUtils.isEmpty(item.publishedAt)) appendDetailLine(sb, getString(R.string.driver_browser_release_date), item.publishedAt);
         appendDetailLine(sb, getString(R.string.driver_browser_release_channel),
                 item.prerelease ? getString(R.string.channel_beta) : getString(R.string.channel_stable));
+        if (item.sourceTrustScore > 0) appendDetailLine(sb, "Source trust", String.valueOf(item.sourceTrustScore));
+        if (!TextUtils.isEmpty(item.sourceRoute)) appendDetailLine(sb, "Source route", item.sourceRoute);
+        if (!TextUtils.isEmpty(item.sourceFallbackChain)) appendDetailLine(sb, "Source fallback chain", item.sourceFallbackChain);
         if (item.recommended) appendDetailLine(sb, getString(R.string.driver_browser_recommended), getString(R.string.driver_browser_recommended_hint));
         if (!TextUtils.isEmpty(item.releaseNotesSnippet)) {
             if (sb.length() > 0) sb.append("\n");
@@ -910,6 +1042,9 @@ public class AdrenotoolsFragment extends Fragment {
         boolean prerelease;
         String sourcePageUrl;
         String sourceLabel;
+        int sourceTrustScore;
+        String sourceRoute;
+        String sourceFallbackChain;
         String releaseNotesSnippet;
         String displayTitle;
         String displaySubtitle;
